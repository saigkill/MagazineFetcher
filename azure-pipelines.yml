trigger:
  branches:
    include:
      - develop
      - master
  tags:
    include:
      - v*

pool:
  vmImage: 'ubuntu-latest'  

variables:
  BuildConfiguration: 'Release'

stages:

# ---------------------------------------------------------
#  STAGE: BUILD (Linux + Windows parallel)
# ---------------------------------------------------------
- stage: Build
  displayName: "Build Linux + Windows"
  jobs:
  - job: MatrixBuild
    displayName: "Matrix Build"
    strategy:
      matrix:
        linux:
          vmImage: 'ubuntu-latest'
          RID: 'linux-x64'
          ArtifactName: '$(AppName)-Linux-$(PackageVersion).zip'
        windows:
          vmImage: 'windows-latest'
          RID: 'win-x64'
          ArtifactName: '$(AppName)-Windows-$(PackageVersion).zip'

    pool:
      vmImage: $(vmImage)

    steps:

    # DotNet SDK
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '9.x'

    # CodeQL nur in develop
    - task: AdvancedSecurity-Codeql-Init@1
      condition: eq(variables['Build.SourceBranch'], 'refs/heads/develop')
      inputs:
        languages: 'csharp'
        querysuite: 'security-and-quality'
      displayName: 'Initialize CodeQL'

    # Publish
    - task: DotNetCoreCLI@2
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: '**/*.csproj'
        arguments: '--configuration $(BuildConfiguration) -r $(RID) --self-contained true --output $(Build.ArtifactStagingDirectory)/$(AppName)'
      displayName: 'Publish Console App'

    # Tests
    - task: DotNetCoreCLI@2
      inputs:
        command: 'test'
        projects: '**/*[Tt]est*/*.csproj'
        arguments: '--collect:"XPlat Code Coverage" --logger:junit /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura'
        testRunTitle: 'dotnet test'
      displayName: 'Run Unit Tests'

    # CodeQL Analyse nur in develop
    - task: AdvancedSecurity-Codeql-Analyze@1
      condition: eq(variables['Build.SourceBranch'], 'refs/heads/develop')
      displayName: 'Perform CodeQL analysis'

    # Test Results
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/TestResults/TestResults.xml'
        testRunTitle: 'Run Testresults'
      displayName: 'Publish Test Results'

    # Coverage
    - task: PublishCodeCoverageResults@2
      inputs:
        summaryFileLocation: '$(Build.SourcesDirectory)/**/coverage.cobertura.xml'
        pathToSources: '$(System.DefaultWorkingDirectory)/**/coverage'
      displayName: 'Publish Code Coverage Results'

    # Coverage Report
    - task: reportgenerator@5
      inputs:
        reports: '$(Build.SourcesDirectory)/**/coverage.cobertura.xml'
        targetdir: '$(Build.SourcesDirectory)/CodeCoverage'
      displayName: 'Generate Code Coverage Report'

    # CodeQL Publish nur in develop
    - task: AdvancedSecurity-Publish@1
      condition: eq(variables['Build.SourceBranch'], 'refs/heads/develop')
      displayName: 'Publish CodeQL results'

    # Mirror to GitHub
    - task: Bash@3
      inputs:
        targetType: 'inline'
        script: |             
          if [ -d "$(AppName)" ]; then
              rm -rf "$(AppName)"
              echo "Das Verzeichnis '$(AppName)' wurde gelöscht."
          else
              echo "Das Verzeichnis '$(AppName)' existiert nicht."
          fi
          
          git clone --mirror https://saigkill:$(AzurePAT)@dev.azure.com/saigkill/$(AppName)/_git/$(AppName) ./$(AppName) --verbose
          cd $(AppName)
          git remote add github https://saigkill:$(GithubPAT)@github.com/saigkill/$(AppName).git
          git push github --mirror
      displayName: 'Mirror to Github'

    # ZIP nur bei Tags
    - task: ArchiveFiles@2      
      inputs:
        rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/$(AppName)'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/$(ArtifactName)'
        replaceExistingArchive: true
      displayName: 'Create ZIP'

    # Artefakt veröffentlichen
    - publish: $(Build.ArtifactStagingDirectory)
      artifact: $(RID)
      displayName: "Publish Artifact"

# ---------------------------------------------------------
#  STAGE: BUILD QPKG (nur Linux)
# ---------------------------------------------------------
- stage: Build_QPKG
  displayName: "Build QNAP QPKG Package"
  dependsOn: Build
  condition: succeeded()

  jobs:
    - job: qpkg
      displayName: "Create QPKG Package"
      pool:
        vmImage: ubuntu-latest

      steps:
        - checkout: self

        # Linux-Build herunterladen
        - task: DownloadPipelineArtifact@2
          displayName: "Download Linux build output"
          inputs:
            artifact: "linux-x64"
            path: "$(Build.SourcesDirectory)/build-output"

        # QPKG-Struktur erzeugen + Startscript + qpkg.cfg
        - script: |
            set -e

            cat <<EOF > InstallToUbuntu.sh
            #!/bin/bash
            if [ -d "/usr/share/QDK" ]; then
              echo "QDK exists."
            else
              apt-get update
              apt-get install -y build-essential wget bsdmainutils curl python3 openssl rsync
            fi
           
            case "$1" in
                 install)
                    echo "Compiler QPKG encrypt"
                    cd src
                    make
                    cd ../
                    echo "Install QDK"
                    cp -rf ./shared /usr/share/QDK
                    [ -d "/etc/config" ] || mkdir "/etc/config"
                    cp ./shared/qdk.conf /etc/config
                    sed -e '2d' ./shared/qdk.conf > /etc/config/qdk.conf
                    sed -i '2iQDK_PATH_P=/usr/share' /etc/config/qdk.conf
                    echo "PATH=$PATH:/usr/share/QDK/bin" >> ~/.bashrc
                    source ~/.bashrc
                ;;
                remove)
                    echo "Remove QDK"
                    rm -rf "/etc/config/qdk.conf"
                    rm -rf "/usr/share/QDK"
                    sed -i '/QDK/d' ~/.bashrc
                    source ~/.bashrc
               ;;
               *)
                    echo "Usage: $0 {install|remove}"
                    exit 1
            esac
            exit 0
            EOF

            chmod +x InstallToUbuntu.sh
            sudo ./InstallToUbuntu.sh install
            cd /usr/share/QDK                     

            # Erstelle Environment
            qbuild --create-env $(AppName)          

            # qpkg.cfg erzeugen
            cat <<EOF > $(AppName)/qpkg.cfg
            QPKG_NAME="$(AppName)"
            QPKG_VER="$(PackageVersion)"
            QPKG_AUTHOR="Sascha Manns"
            QPKG_SUMMARY="Automatic Magazin-Downloader for Torrents via RSS"
            QPKG_RC_NUM="100"
            QPKG_SERVICE_PROGRAM="$(AppName).sh"
            EOF

            # Startscript erzeugen
            cat <<'EOF' > $(AppName)/shared/$(AppName).sh
            #!/bin/sh
            QPKG_NAME="$(AppName)"
            QPKG_DIR="$(dirname "$0")"
            APP_DIR="${QPKG_DIR}/build"
            LOG_DIR="${QPKG_DIR}/logs"
            PID_FILE="${QPKG_DIR}/magazinefetcher.pid"

            APP_BIN="${APP_DIR}/$(AppName)"            

            mkdir -p "$LOG_DIR"

            start_app() {
                if [ -f "$PID_FILE" ] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
                    echo "$QPKG_NAME läuft bereits."
                    exit 0
                fi

                echo "Starte $QPKG_NAME..."

                nohup "$APP_BIN" >> "$LOG_DIR/output.log" 2>&1 &

                echo $! > "$PID_FILE"

                echo "$QPKG_NAME gestartet (PID $(cat "$PID_FILE"))."
            }

            stop_app() {
                if [ ! -f "$PID_FILE" ]; then
                    echo "$QPKG_NAME läuft nicht."
                    exit 0
                fi

                PID=$(cat "$PID_FILE")

                echo "Stoppe $QPKG_NAME (PID $PID)..."

                kill "$PID" 2>/dev/null

                for i in $(seq 1 10); do
                    if kill -0 "$PID" 2>/dev/null; then
                        sleep 1
                    else
                        break
                    fi
                done

                if kill -0 "$PID" 2>/dev/null; then
                    echo "Prozess reagiert nicht – erzwinge Kill."
                    kill -9 "$PID" 2>/dev/null
                fi

                rm -f "$PID_FILE"
                echo "$QPKG_NAME gestoppt."
            }

            case "$1" in
                start) start_app ;;
                stop) stop_app ;;
                restart) stop_app; start_app ;;
                *) echo "Usage: $0 {start|stop|restart}"; exit 1 ;;
            esac

            exit 0
            EOF

            chmod +x $(AppName)/shared/$(AppName).sh

            # Build-Output kopieren
            cp -r $(Build.SourcesDirectory)/build-output/* x86_64

            # QPKG erstellen
            qbuild
          displayName: "Assemble QPKG"

        # Artifact veröffentlichen
        - task: PublishPipelineArtifact@1
          displayName: "Publish QPKG"
          inputs:
            targetPath: "$(Build.SourcesDirectory)/$(AppName)-$(PackageVersion).qpkg"
            artifact: "qpkg"

# ---------------------------------------------------------
#  STAGE: RELEASE (nur bei Tags)
# ---------------------------------------------------------
- stage: Release
  displayName: "Create GitHub Release"
  dependsOn: Build_QPKG
  condition: startsWith(variables['Build.SourceBranch'], 'refs/tags/')
  jobs:
  - job: ReleaseJob
    pool:
      vmImage: 'ubuntu-latest'
    steps:

    - download: current
      artifact: linux-x64

    - download: current
      artifact: win-x64

    - task: DownloadPipelineArtifact@2
      displayName: "Download QPKG"
      inputs:
        artifact: "qpkg"
        path: "$(Build.SourcesDirectory)/release"

    - task: GitHubRelease@1
      inputs:
        gitHubConnection: 'github.com_saigkill'
        repositoryName: 'saigkill/$(AppName)'
        action: 'create'
        tagSource: 'gitTag'
        assets: |
          $(Pipeline.Workspace)/linux-x64/*.zip
          $(Pipeline.Workspace)/win-x64/*.zip
          $(Build.SourcesDirectory)/release/*.qpkg
        title: 'Release $(Build.SourceBranchName)'
        isDraft: false
        isPreRelease: false
      displayName: 'Create GitHub Release'
