trigger:
  branches:
    include:
      - develop
      - master
  tags:
    include:
      - v*

pool:
  vmImage: 'ubuntu-latest'

variables:
  BuildConfiguration: 'Release'

stages:

# ---------------------------------------------------------
#  STAGE: BUILD (Linux + Windows parallel)
# ---------------------------------------------------------
- stage: Build
  displayName: "Build Linux + Windows"
  jobs:
  - job: MatrixBuild
    displayName: "Matrix Build"
    strategy:
      matrix:
        linux:
          vmImage: 'ubuntu-latest'
          RID: 'linux-x64'
          ArtifactName: 'MagazineFetcher-Linux.zip'
        windows:
          vmImage: 'windows-latest'
          RID: 'win-x64'
          ArtifactName: 'MagazineFetcher-Windows.zip'

    pool:
      vmImage: $(vmImage)

    steps:

    # DotNet SDK
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '9.x'

    # CodeQL nur in develop
    - task: AdvancedSecurity-Codeql-Init@1
      condition: eq(variables['Build.SourceBranch'], 'refs/heads/develop')
      inputs:
        languages: 'csharp'
        querysuite: 'security-and-quality'
      displayName: 'Initialize CodeQL'

    # Publish
    - task: DotNetCoreCLI@2
      inputs:
        command: 'publish'
        publishWebProjects: false
        projects: '**/*.csproj'
        arguments: '--configuration $(BuildConfiguration) -r $(RID) --self-contained true --output $(Build.ArtifactStagingDirectory)/MagazineFetcher'
      displayName: 'Publish Console App'

    # Tests
    - task: DotNetCoreCLI@2
      inputs:
        command: 'test'
        projects: '**/*[Tt]est*/*.csproj'
        arguments: '--collect:"XPlat Code Coverage" --logger:junit /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura'
        testRunTitle: 'dotnet test'
      displayName: 'Run Unit Tests'

    # CodeQL Analyse nur in develop
    - task: AdvancedSecurity-Codeql-Analyze@1
      condition: eq(variables['Build.SourceBranch'], 'refs/heads/develop')
      displayName: 'Perform CodeQL analysis'

    # Test Results
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/TestResults/TestResults.xml'
        testRunTitle: 'Run Testresults'
      displayName: 'Publish Test Results'

    # Coverage
    - task: PublishCodeCoverageResults@2
      inputs:
        summaryFileLocation: '$(Build.SourcesDirectory)/**/coverage.cobertura.xml'
        pathToSources: '$(System.DefaultWorkingDirectory)/**/coverage'
      displayName: 'Publish Code Coverage Results'

    # Coverage Report
    - task: reportgenerator@5
      inputs:
        reports: '$(Build.SourcesDirectory)/**/coverage.cobertura.xml'
        targetdir: '$(Build.SourcesDirectory)/CodeCoverage'
      displayName: 'Generate Code Coverage Report'

    # CodeQL Publish nur in develop
    - task: AdvancedSecurity-Publish@1
      condition: eq(variables['Build.SourceBranch'], 'refs/heads/develop')
      displayName: 'Publish CodeQL results'

    # Mirror to GitHub
    - task: Bash@3
      inputs:
        targetType: 'inline'
        script: |
          DIR="MagazineFetcher"
          
          if [ -d "$DIR" ]; then
              rm -rf "$DIR"
              echo "Das Verzeichnis '$DIR' wurde gelöscht."
          else
              echo "Das Verzeichnis '$DIR' existiert nicht."
          fi
          
          git clone --mirror https://saigkill:$AzurePAT@dev.azure.com/saigkill/$DIR/_git/$DIR ./$DIR --verbose
          cd $DIR
          git remote add github https://saigkill:$(GithubPAT)@github.com/saigkill/$DIR.git
          git push github --mirror
      displayName: 'Mirror to Github'

    # ZIP nur bei Tags
    - task: ArchiveFiles@2
      condition: startsWith(variables['Build.SourceBranch'], 'refs/tags/')
      inputs:
        rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/MagazineFetcher'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/$(ArtifactName)'
        replaceExistingArchive: true
      displayName: 'Create ZIP'

    # Artefakt veröffentlichen
    - publish: $(Build.ArtifactStagingDirectory)
      artifact: $(RID)
      condition: startsWith(variables['Build.SourceBranch'], 'refs/tags/')
      displayName: "Publish Artifact"

# ---------------------------------------------------------
#  STAGE: BUILD QPKG (nur Linux)
# ---------------------------------------------------------
- stage: Build_QPKG
  displayName: "Build QNAP QPKG Package"
  dependsOn: Build
  condition: succeeded()

  jobs:
    - job: qpkg
      displayName: "Create QPKG Package"
      pool:
        vmImage: ubuntu-latest

      steps:
        - checkout: self

        # Linux-Build herunterladen
        - task: DownloadPipelineArtifact@2
          displayName: "Download Linux build output"
          inputs:
            artifact: "linux-x64"
            path: "$(Build.SourcesDirectory)/build-output"

        # QPKG-Struktur erzeugen + Startscript + qpkg.cfg
        - script: |
            set -e

            mkdir -p qpkg/build
            mkdir -p qpkg/logs

            # qpkg.cfg erzeugen
            cat <<EOF > qpkg/qpkg.cfg
            QPKG_NAME="MagazineFetcher"
            QPKG_VER="$(Build.SourceBranchName)"
            QPKG_AUTHOR="Sascha Manns"
            QPKG_SUMMARY="Automatic Magazin-Downloader for Torrents via RSS"
            QPKG_RC_NUM="100"
            QPKG_SERVICE_PROGRAM="start.sh"
            EOF

            # Startscript erzeugen
            cat <<'EOF' > qpkg/start.sh
            #!/bin/sh
            QPKG_NAME="MagazineFetcher"
            QPKG_DIR="$(dirname "$0")"
            APP_DIR="${QPKG_DIR}/build"
            LOG_DIR="${QPKG_DIR}/logs"
            PID_FILE="${QPKG_DIR}/magazinefetcher.pid"

            APP_BIN="${APP_DIR}/MagazineFetcher"            

            mkdir -p "$LOG_DIR"

            start_app() {
                if [ -f "$PID_FILE" ] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
                    echo "$QPKG_NAME läuft bereits."
                    exit 0
                fi

                echo "Starte $QPKG_NAME..."

                nohup "$APP_BIN" >> "$LOG_DIR/output.log" 2>&1 &

                echo $! > "$PID_FILE"

                echo "$QPKG_NAME gestartet (PID $(cat "$PID_FILE"))."
            }

            stop_app() {
                if [ ! -f "$PID_FILE" ]; then
                    echo "$QPKG_NAME läuft nicht."
                    exit 0
                fi

                PID=$(cat "$PID_FILE")

                echo "Stoppe $QPKG_NAME (PID $PID)..."

                kill "$PID" 2>/dev/null

                for i in $(seq 1 10); do
                    if kill -0 "$PID" 2>/dev/null; then
                        sleep 1
                    else
                        break
                    fi
                done

                if kill -0 "$PID" 2>/dev/null; then
                    echo "Prozess reagiert nicht – erzwinge Kill."
                    kill -9 "$PID" 2>/dev/null
                fi

                rm -f "$PID_FILE"
                echo "$QPKG_NAME gestoppt."
            }

            case "$1" in
                start) start_app ;;
                stop) stop_app ;;
                restart) stop_app; start_app ;;
                *) echo "Usage: $0 {start|stop|restart}"; exit 1 ;;
            esac

            exit 0
            EOF

            chmod +x qpkg/start.sh

            # Build-Output kopieren
            cp -r build-output/MagazineFetcher/* qpkg/build/

            # QPKG erstellen
            cd qpkg
            tar -czf ../MagazineFetcher.qpkg *
          displayName: "Assemble QPKG"

        # Artifact veröffentlichen
        - task: PublishPipelineArtifact@1
          displayName: "Publish QPKG"
          inputs:
            targetPath: "$(Build.SourcesDirectory)/MagazineFetcher.qpkg"
            artifact: "qpkg"

# ---------------------------------------------------------
#  STAGE: RELEASE (nur bei Tags)
# ---------------------------------------------------------
- stage: Release
  displayName: "Create GitHub Release"
  dependsOn: Build, Build_QPKG
  condition: startsWith(variables['Build.SourceBranch'], 'refs/tags/')
  jobs:
  - job: ReleaseJob
    pool:
      vmImage: 'ubuntu-latest'
    steps:

    - download: current
      artifact: linux-x64

    - download: current
      artifact: win-x64

    - task: DownloadPipelineArtifact@2
      displayName: "Download QPKG"
      inputs:
        artifact: "qpkg"
        path: "$(Build.SourcesDirectory)/release"

    - task: GitHubRelease@1
      inputs:
        gitHubConnection: 'github.com_saigkill'
        repositoryName: 'saigkill/MagazineFetcher'
        action: 'create'
        tagSource: 'gitTag'
        assets: |
          $(Pipeline.Workspace)/linux-x64/*.zip
          $(Pipeline.Workspace)/win-x64/*.zip
          $(Build.SourcesDirectory)/release/*.qpkg
        title: 'Release $(Build.SourceBranchName)'
        isDraft: false
        isPreRelease: false
      displayName: 'Create GitHub Release'
